{
  "id": "hianime",
  "name": "HiAnime",
  "version": "1.0.0",
  "manifestURI": "https://raw.githubusercontent.com/Babyretro/SeanimeX/main/src/HiAnime/manifest.json",
  "language": "typescript",
  "type": "onlinestream-provider",
  "description": "HiAnime streaming provider using hianime.pe search API",
  "author": "YourName",
  "icon": "",
  "website": "https://hianime.pe",
  "lang": "en",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n\nclass Provider {\n  private baseUrl = \"https://hianime.pe\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"Default\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    const keyword = encodeURIComponent(query.query);\n    const res = await fetch(`${this.baseUrl}/ajax/search/suggest?keyword=${keyword}`, {\n      headers: {\n        \"User-Agent\": \"Mozilla/5.0\",\n        \"Accept\": \"application/json\",\n        \"Referer\": this.baseUrl + \"/\",\n        \"Origin\": this.baseUrl\n      }\n    });\n\n    if (!res.ok) throw new Error(`Search failed: ${res.statusText}`);\n\n    const data = await res.json();\n    const results: SearchResult[] = [];\n\n    if (Array.isArray(data)) {\n      for (const item of data) {\n        results.push({\n          id: item.id.toString(),\n          title: item.title || item.anime_title || \"\",\n          url: `${this.baseUrl}/anime/${item.slug || item.id}`,\n          subOrDub: \"both\"\n        });\n      }\n    }\n\n    return results;\n  }\n\n  async findEpisodes(animeId: string): Promise<Episode[]> {\n    // Fetch anime page to extract episodes or fetch episodes API if available\n    const res = await fetch(`${this.baseUrl}/anime/${animeId}`, {\n      headers: {\n        \"User-Agent\": \"Mozilla/5.0\",\n        \"Accept\": \"text/html\",\n        \"Referer\": this.baseUrl + \"/\",\n        \"Origin\": this.baseUrl\n      }\n    });\n\n    if (!res.ok) throw new Error(`Fetch episodes failed: ${res.statusText}`);\n\n    const html = await res.text();\n    // Basic parsing with regex to extract episode list (adjust selector as per real HTML)\n    const episodeRegex = /<a href=\"(\\/watch\\/[^\\\"]+)\"[^>]*>(Episode \\d+)<\\/a>/g;\n    const episodes: Episode[] = [];\n    let match;\n    let epNumber = 1;\n    while ((match = episodeRegex.exec(html)) !== null) {\n      episodes.push({\n        id: match[1],\n        number: epNumber++,\n        title: match[2],\n        url: `${this.baseUrl}${match[1]}`\n      });\n    }\n\n    if (episodes.length === 0) {\n      throw new Error(\"No episodes found\");\n    }\n\n    return episodes;\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n    // Fetch episode page to extract video source URLs\n    const res = await fetch(episode.url, {\n      headers: {\n        \"User-Agent\": \"Mozilla/5.0\",\n        \"Accept\": \"text/html\",\n        \"Referer\": this.baseUrl + \"/\",\n        \"Origin\": this.baseUrl\n      }\n    });\n\n    if (!res.ok) throw new Error(`Fetch stream failed: ${res.statusText}`);\n\n    const html = await res.text();\n    // Parse video URL(s) from player embed or script (adjust regex as needed)\n    const sourceRegex = /source src=\"([^\"]+)\"/g;\n    const videoSources: VideoSource[] = [];\n    let match;\n    while ((match = sourceRegex.exec(html)) !== null) {\n      videoSources.push({\n        url: match[1],\n        quality: \"auto\",\n        type: \"mp4\",\n        subtitles: []\n      });\n    }\n\n    if (videoSources.length === 0) {\n      throw new Error(\"No video sources found\");\n    }\n\n    return {\n      server: _server || \"Default\",\n      headers: {\n        \"Referer\": this.baseUrl + \"/\",\n        \"User-Agent\": \"Mozilla/5.0\"\n      },\n      videoSources\n    };\n  }\n}\n"
}
